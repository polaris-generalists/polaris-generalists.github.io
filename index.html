<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PolaRiS</title>
  <link rel="icon" href="./figs/logo.png" type="image/png">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="top-nav">
    <div class="nav-brand">PolaRiS</div>
    <div class="nav-links">
      <a href="#slider-comparison">Real vs Sim</a>
      <a href="#abstract">TL;DR</a>
      <a href="#pipeline">Pipeline</a>
      <a href="#co-training">Co-training</a>
      <a href="#results">Results</a>
      <a href="#gallery">Gallery</a>
      <a href="#bibtex">BibTeX</a>
    </div>
    <div class="nav-actions">
      <a class="nav-btn primary" href="./VideoMimic.pdf" target="_blank">Paper</a>
      <a class="nav-btn" href="https://github.com/hongsukchoi/VideoMimic" target="_blank">Code</a>
    </div>
  </div>

  <div class="main-content">
    <div class="hero-flow">
      <div class="hero-text">PolaRiS</div>
      <div class="sub-hero-text">Scalable Real-to-Sim Evaluations for Generalist Robot Policies</div>

      <div class="hero-pill-row">
        <span class="hero-pill">Real to Sim Reconstruction</span>
        <span class="hero-pill">Simulation Co-training</span>
        <span class="hero-pill">Zero-shot Evaluation</span>
      </div>

      <div class="authors">
        <a href="https://allshire.org/" target="_blank">Arthur Allshire*</a>, <a href="https://hongsukchoi.github.io/" target="_blank">Hongsuk Choi*</a>, <a href="https://www.junyi42.com/" target="_blank">Junyi Zhang*</a>, <a href="https://mcallisterdavid.com/" target="_blank">David McAllister*</a>, <a href="https://antoniomacaronio.github.io/personal-website/#/home/" target="_blank">Anthony Zhang</a>, <a href="https://chungmin99.github.io/" target="_blank">Chung Min Kim</a>,<br>
        <a href="https://people.eecs.berkeley.edu/~trevor/" target="_blank">Trevor Darrell</a>, <a href="https://people.eecs.berkeley.edu/~pabbeel/" target="_blank">Pieter Abbeel</a>, <a href="https://people.eecs.berkeley.edu/~malik/" target="_blank">Jitendra Malik</a>, <a href="https://people.eecs.berkeley.edu/~kanazawa/" target="_blank">Angjoo Kanazawa</a>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*:equal contribution)
        <span class="affiliation">University of California, Berkeley</span>
      </div>

      <div class="hero-actions">
        <a class="cta primary" href="./VideoMimic.pdf" target="_blank">Read the paper</a>
        <a class="cta ghost" href="#slider-comparison">Watch comparison</a>
      </div>

      <div class="hero-waves" aria-hidden="true">
        <svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
          <defs>
            <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
          </defs>
          <g class="wave-parallax">
            <use xlink:href="#gentle-wave" x="48" y="0" fill="rgba(15,106,52,0.55)"></use>
            <use xlink:href="#gentle-wave" x="48" y="3" fill="rgba(12,85,42,0.45)"></use>
            <use xlink:href="#gentle-wave" x="48" y="5" fill="rgba(15,106,52,0.30)"></use>
            <use xlink:href="#gentle-wave" x="48" y="7" fill="rgba(6,54,24,0.65)"></use>
          </g>
        </svg>
      </div>
    </div>

    <div class="quick-links">
      <a href="./VideoMimic.pdf" target="_blank">[pdf]</a>
      <a href="https://arxiv.org/abs/2505.03729" target="_blank">[arxiv]</a>
      <a href="https://github.com/hongsukchoi/VideoMimic" target="_blank">[code]</a>
    </div>

    <!-- Teaser Figure -->
    <img src="./figs/teaser.png" alt="PolaRiS teaser figure" />
    <p class="figure-caption">
      PolaRiS is a real-to-sim approach for constructing high-fidelity simulated environments for scalable evaluation. PolaRiS’s 3D Gaussian splatting–based framework quickly turns a short video of a real-world scene into a simulation environment. We use PolaRiS to create a diverse suite of simulated environments and demonstrate strong correlations to real-world evaluations for generalist robot policies.
    </p>

    <div class="tagline">Real vs. Sim</div>
    <section class="slider-section card-surface" id="slider-comparison">
      <div class="section-heading">Interactive Slider Comparison</div>
      <p class="section-lead">Drag to reveal the same DROID robot in the real world and in a PolaRiS-generated simulation.</p>
      <div class="slider-wrapper">
        <video class="slider-video" src="./single/sim.mp4" autoplay muted loop playsinline></video>
        <div class="slider-overlay">
          <video class="slider-video" src="./single/input.mp4" autoplay muted loop playsinline></video>
        </div>
        <div class="slider-handle"></div>
        <input type="range" class="slider-input" min="0" max="100" value="50" aria-label="Reveal real or simulated video">
      </div>
      <p class="figure-caption slider-caption"><b>PolaRiS</b> enables zero-shot evaluation in unseen simulation environments that correlates strongly with real-world performance.</p>
    </section>

    <div class="tagline" id="abstract">Abstract / TL;DR</div>
    <div class="section card-surface abstract-card" tabindex="0" aria-label="Hover or focus to read full abstract">
      <div class="abstract-teaser">
        <p>We introduce PolaRiS, a scalable real-to-sim framework for high-fidelity robot evaluation. PolaRiS turns short scans into interactive environments via 2D Gaussian Splatting, co-trains on a small number of sim episodes to bridge the visual gap, and provides accurate policy ranking without additional real rollouts.</p>
        <p>Through paired sim/real evaluations, PolaRiS delivers substantially stronger real-world correlation for generalist policies.</p>
      </div>
      <div class="abstract-full" aria-hidden="true">
        <p>A major challenge for robot learning research is our ability to accurately measure and compare the performance of robot policies. Benchmarking in robotics is historically challenging due to the stochasticity, reproducibility, and time-consuming nature of real-world rollouts. This challenge is exacerbated for recent generalist policies, which need to be evaluated across numerous scenes and tasks. Evaluation in simulation offers a scalable complement to real world evaluations, but the visual and physical domain gap between existing simulation benchmarks and the real world has made them an unreliable signal for policy improvement. Furthermore, building realistic and diverse simulated environments has traditionally required significant human effort and expertise.</p>
        <p></p>To bridge the gap, we introduce <b>Policy Evaluation and Environment Reconstruction in Simulation (PolaRiS)</b>, a scalable real-to-sim framework for high-fidelity simulated robot evaluation. PolaRiS uses neural reconstruction methods to turn short video scans of real-world scenes into interactive simulation environments. Further, we develop a simple simulation data co-training recipe that bridges remaining real-to-sim gaps and enables zero-shot evaluation in unseen simulation environments. Through extensive paired evaluations between simulation and the real world, we demonstrate that PolaRiS evaluations provide a much stronger correlation to real world generalist policy performance than existing simulated benchmarks. Its simplicity also enables rapid creation of diverse simulated environments.</p>
        <p>As such, this work takes a step towards distributed and democratized evaluation for the next generation of robotic foundation models.</p>
      </div>
      <div class="abstract-hint">Hover or focus to reveal full abstract</div>
      <div class="tldr-grid">
        <div class="tldr-card" tabindex="0">
          <div class="tldr-label">Scan</div>
          <p>Turn short video scans into interactive environments using 2D Gaussian Splatting.</p>
          <video class="tldr-video" src="./reconstruction_input_videos/1.mp4" autoplay muted loop playsinline></video>
        </div>
        <div class="tldr-card" tabindex="0">
          <div class="tldr-label">Align</div>
          <p>Bridge the visual gap with a light co-training recipe on a few hundred simulated episodes.</p>
          <video class="tldr-video" src="./train_in_sim/vid2_rl.mp4" autoplay muted loop playsinline></video>
        </div>
        <div class="tldr-card" tabindex="0">
          <div class="tldr-label">Evaluate</div>
          <p>Rank policies accurately in sim—no additional real-world rollouts required.</p>
          <video class="tldr-video" src="./single/sim.mp4" autoplay muted loop playsinline></video>
        </div>
      </div>
    </div>

    <div class="tagline" id="pipeline">The PolaRiS Pipeline: From Video to Eval</div>
    <div class="pipeline-grid card-surface">
      <div class="pipeline-card">
        <div class="pipeline-step">Step 1 — Environment Scan</div>
        <video src="./reconstruction_input_videos/1.mp4" autoplay muted loop playsinline></video>
        <p>A 2–5 minute handheld phone scan captures geometry and appearance. ChArUco for metric scale; minimal user effort.</p>
      </div>
      <div class="pipeline-card">
        <div class="pipeline-step">Step 2 — Neural Reconstruction</div>
        <video src="./reconstruction/6.mp4" autoplay muted loop playsinline></video>
        <p>2D Gaussian Splatting (2DGS) recovers photorealistic visuals. We extract meshes for collision and contact-aware simulation.</p>
      </div>
      <div class="pipeline-card">
        <div class="pipeline-step">Step 3 — Object & Robot Insertion</div>
        <video src="assets/videos/real2sim/guivideo.mp4" autoplay muted loop playsinline></video>
        <p>Robots are articulated with kinematics-aware splats. Objects are generated from single images (TRELLIS) and made physics-ready.</p>
      </div>
    </div>

    <div class="tagline" id="object-reconstruction">Object Generation</div>
    <div class="card-surface mesh-viewer">
      <div class="mesh-header">
        <div>
          <div class="section-heading">Interact with mesh generation</div>
          <p class="section-lead">Preview TRELLIS-generated object meshes; switch objects and orbit the assets.</p>
      </div>
        <label class="mesh-selector">
          <span>Select object</span>
          <select id="meshSelect">
            <option value="cleaner">Cleaner</option>
            <option value="coke">Coke</option>
            <option value="electricdrill">Electric Drill</option>
            <option value="pot">Pot</option>
            <option value="scissor">Scissor</option>
            <option value="spoon">Spoon</option>
          </select>
        </label>
      </div>

      <div class="mesh-active-label">Showing: <span id="meshActiveName">Cleaner</span></div>

      <div class="mesh-columns">
        <div class="mesh-col mesh-media">
          <div class="mesh-col-title">Object Scan</div>
          <video id="meshVideo" class="mesh-video" playsinline muted loop controls></video>
          <div class="mesh-note" id="meshVideoNote"></div>
        </div>
        <div class="mesh-col">
          <div class="mesh-col-title">Object Mesh</div>
          <model-viewer id="meshRaw" class="mesh-viewer-frame" alt="TRELLIS visual mesh" loading="lazy"
            camera-controls auto-rotate rotation-per-second="30deg" camera-orbit="auto auto 600%"
            min-camera-orbit="auto auto 200%" max-camera-orbit="auto auto 1000%" field-of-view="85deg"
            exposure="1" shadow-intensity="0.4" src="./assets/trellis/mesh_cleaner.glb">
          </model-viewer>
      </div>
      </div>
    </div>

    <div class="tagline" id="co-training">Key Insight: Simulation Data Co-Training</div>
    <div class="side-by-side card-surface insight-block">
      <div class="side-card">
        <div class="side-label muted">No Co-training</div>
        <video src="./train_in_sim/vid1_rl.mp4" autoplay muted loop playsinline></video>
        <p>Raw real-to-sim transfer struggles with lighting and shadow shifts; grasping fails.</p>
      </div>
      <div class="side-card">
        <div class="side-label accent">With Co-training</div>
        <video src="./train_in_sim/vid2_rl.mp4" autoplay muted loop playsinline></video>
        <p>Finetuning on a few hundred simulated episodes aligns visual representations and restores task success.</p>
      </div>
    </div>
    <p class="figure-caption">Co-training enables robust zero-shot evaluation in completely unseen simulation environments.</p>

    <div class="co-gallery card-surface">
      <div class="section-heading">Simulation Data Co-Training Gallery</div>
      <p class="section-lead">Diverse simulated rollouts used for visual alignment: varying lighting, viewpoints, and object configurations.</p>
      <div class="co-gallery-grid">
        <div class="co-gallery-card">
          <video src="./assets/videos/cotrain/workbench_zed_episode_0_images_merged.mp4" autoplay muted loop playsinline></video>
          <div class="co-caption">Workbench zed</div>
        </div>
        <div class="co-gallery-card">
          <video src="./assets/videos/cotrain/vention_episode_0_images_merged.mp4" autoplay muted loop playsinline></video>
          <div class="co-caption">Vention table</div>
        </div>
        <div class="co-gallery-card">
          <video src="./assets/videos/cotrain/lobby_desk_episode_0_images_merged.mp4" autoplay muted loop playsinline></video>
          <div class="co-caption">Lobby desk</div>
        </div>
        <div class="co-gallery-card">
          <video src="./assets/videos/cotrain/kanav_maddox_table_episode_0_images_merged.mp4" autoplay muted loop playsinline></video>
          <div class="co-caption">Maddox table</div>
        </div>
        <div class="co-gallery-card">
          <video src="./assets/videos/cotrain/kanav_geodude_episode_0_images_merged.mp4" autoplay muted loop playsinline></video>
          <div class="co-caption">Geodude setup</div>
        </div>
        <div class="co-gallery-card">
          <video src="./assets/videos/cotrain/kanav_circle_table_episode_0_images_merged.mp4" autoplay muted loop playsinline></video>
          <div class="co-caption">Circle table</div>
        </div>
        <div class="co-gallery-card">
          <video src="./assets/videos/cotrain/kanav_black_table_episode_0_images_merged.mp4" autoplay muted loop playsinline></video>
          <div class="co-caption">Black table</div>
        </div>
        <div class="co-gallery-card">
          <video src="./assets/videos/cotrain/envs_05_episode_0_images_merged.mp4" autoplay muted loop playsinline></video>
          <div class="co-caption">Env suite 05</div>
        </div>
        <div class="co-gallery-card">
          <video src="./assets/videos/cotrain/envs_00_episode_0_images_merged.mp4" autoplay muted loop playsinline></video>
          <div class="co-caption">Env suite 00</div>
        </div>
      </div>
    </div>

    <div class="card-surface correlation-callout">
      <div class="section-heading">Real ↔ Sim correlation from co-training</div>
      <p class="section-lead">Co-training tightens the slope and lowers variance between simulated rollouts and paired real executions.</p>
      <div class="metric-grid">
        <div class="metric-card">
          <div class="metric-value">ρ = 0.82</div>
          <div class="metric-label">After co-training</div>
          <p>Rank correlation between sim and real policy scores across held-out scenes.</p>
        </div>
        <div class="metric-card">
          <div class="metric-value">+0.27</div>
          <div class="metric-label">Δ over baseline</div>
          <p>Improvement vs. raw real-to-sim transfer without alignment data.</p>
        </div>
        <div class="metric-card">
          <div class="metric-value">150</div>
          <div class="metric-label">sim episodes</div>
          <p>Lightweight finetuning budget used to close the visual gap.</p>
        </div>
      </div>
      <ul class="evidence-list">
        <li>Paired sim/real rollouts per task; shared action traces, identical prompts.</li>
        <li>Scenes span lighting shifts, clutter changes, and camera baselines.</li>
        <li>Correlation reported on unseen scenes after alignment.</li>
      </ul>
    </div>

    <div class="tagline" id="results">Results: Real-Sim Correlation</div>
    <div class="stats-grid card-surface">
      <div class="stat-card">
        <div class="stat-number">Evaluating what matters</div>
        <p>PolaRiS rankings track real-world policy performance significantly better than prior simulated benchmarks.</p>
      </div>
      <div class="stat-card">
        <div class="stat-number">Pearson r ≈ 0.78</div>
        <p>Strong sim↔real correlation vs. near-zero for LIBERO-style baselines.</p>
      </div>
      <div class="stat-card">
        <div class="stat-number">Rank preserved</div>
        <p>Policy ordering in PolaRiS matches real-world ordering; standard sims do not.</p>
      </div>
    </div>
    <div class="card-surface scatter-card">
      <div class="section-heading">Interactive correlation plot</div>
      <p class="section-lead">Hover points to see paired sim/real success; higher correlation with co-training.</p>
      <svg id="corr-scatter" viewBox="0 0 520 320" role="img" aria-label="Simulation vs Real success scatter"></svg>
      <div class="scatter-hint">Tip: hover a point to see its policy, environment, and Sim/Real success. Blue squares = PolaRiS; gray circles = LIBERO.</div>
      <div class="scatter-status" id="scatter-status">Loading results…</div>
      <div class="scatter-legend" id="policy-legend"></div>
      <div class="scatter-legend" id="env-legend"></div>
      <div class="rank-lists">
        <div>
          <div class="rank-title">Real-world ranking</div>
          <ol>
            <li>π<sub>0.5</sub></li>
            <li>π<sub>0</sub></li>
            <li>PaliGemma</li>
          </ol>
        </div>
        <div>
          <div class="rank-title">PolaRiS ranking</div>
          <ol>
            <li>π<sub>0.5</sub></li>
            <li>π<sub>0</sub></li>
            <li>PaliGemma</li>
          </ol>
        </div>
        <div>
          <div class="rank-title">Standard sim ranking</div>
          <ol>
            <li>Random / flat</li>
          </ol>
        </div>
      </div>
    </div>

    <div class="card-surface bar-card">
      <div class="section-heading">Interactive bar plot (Sim vs Real per Environment)</div>
      <p class="section-lead">PolaRiS sim scores track real performance; hover for exact values.</p>
      <div class="bar-plot-wrap">
        <svg id="bar-plot" viewBox="0 0 640 360" role="img" aria-label="Simulation vs Real bar plot"></svg>
      </div>
      <div class="scatter-status" id="bar-status">Loading bar data…</div>
    </div>

    <div class="card-surface policy-card" id="policy-comparison">
      <div class="section-heading">Policy Evaluation Comparison (Sim vs Real)</div>
      <p class="section-lead">Side-by-side sim and real performance across environments for key policies.</p>
      <div class="policy-list" id="policy-list"></div>
      <div class="scatter-status" id="policy-status">Loading policy data…</div>
    </div>

    <div class="card-surface video-card" id="policy-videos">
      <div class="section-heading">Evaluation Videos</div>
      <p class="section-lead">Sample rollouts for the same policies and environments.</p>
      <div class="video-grid" id="policy-video-grid"></div>
      <div class="scatter-status" id="policy-video-status">Loading videos…</div>
    </div>

    <div class="tagline" id="gallery">Diverse, Generatable Evaluation Scenes</div>
    <div class="card-surface">
      <p class="section-lead">All environments below were produced from short video scans; policies are evaluated zero-shot.</p>
      <div class="gallery-grid">
      <video src="./reconstruction/1.mp4" autoplay muted loop playsinline></video>
      <video src="./reconstruction/4.mp4" autoplay muted loop playsinline></video>
      <video src="./reconstruction/6.mp4" autoplay muted loop playsinline></video>
      <video src="./reconstruction/7.mp4" autoplay muted loop playsinline></video>
      <video src="./reconstruction/11.mp4" autoplay muted loop playsinline></video>
      <video src="./reconstruction/13.mp4" autoplay muted loop playsinline></video>
      <video src="./reconstruction/14.mp4" autoplay muted loop playsinline></video>
      <video src="./traversing/1.mp4" autoplay muted loop playsinline></video>
      <video src="./sitting/3.mp4" autoplay muted loop playsinline></video>
      </div>
    </div>

    <div class="tagline" id="visual-fidelity">Visual Fidelity Ablation</div>
    <div class="card-surface">
      <p class="section-lead">
        Visual fidelity variants of the same scenes: Gaussian splatting (ours), ray traced, untextured environment, and untextured everything.
      </p>
      <div class="gallery-grid">
        <video src="./assets/videos/vidual_fidelity/splats.mp4" autoplay muted loop playsinline></video>
        <video src="./assets/videos/vidual_fidelity/raytraced.mp4" autoplay muted loop playsinline></video>
        <video src="./assets/videos/vidual_fidelity/untextured_env.mp4" autoplay muted loop playsinline></video>
        <video src="./assets/videos/vidual_fidelity/untextured_everything.mp4" autoplay muted loop playsinline></video>
      </div>
    </div>

    <div class="tagline" id="bibtex">BibTeX</div>
    <div class="bibtex-code">
      <div class="bibtex-title">Reference</div>
<pre><code>@article{polaris2025,
  title   = {Policy Evaluation and Environment Reconstruction in Simulation (PolaRiS)},
  author  = {Allshire, Arthur and Choi, Hongsuk and Zhang, Junyi and McAllister, David and Zhang, Anthony and Kim, Chung Min and Darrell, Trevor and Abbeel, Pieter and Malik, Jitendra and Kanazawa, Angjoo},
  journal = {arXiv preprint arXiv:2505.03729},
  year    = {2025}
}</code></pre>
    </div>
  </div>

  <div class="footer">
     © UC Berkeley | PolaRiS team. Source code is available <a href="https://github.com/videomimic-1/videomimic-1.github.io" target="_blank">here</a>.
  </div>

  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const sliderSection = document.getElementById('slider-comparison');
      if (!sliderSection) return;

      const range = sliderSection.querySelector('.slider-input');
      const overlay = sliderSection.querySelector('.slider-overlay');
      const handle = sliderSection.querySelector('.slider-handle');

      const updateSlider = (value) => {
        const clamped = Math.max(0, Math.min(100, value));
        overlay.style.width = clamped + '%';
        handle.style.left = clamped + '%';
      };

      range?.addEventListener('input', (e) => updateSlider(Number(e.target.value)));
      range?.addEventListener('change', (e) => updateSlider(Number(e.target.value)));
      updateSlider(Number(range?.value || 50));
    });


    // TRELLIS mesh switcher
    document.addEventListener('DOMContentLoaded', () => {
      const select = document.getElementById('meshSelect');
      const raw = document.getElementById('meshRaw');
      const activeName = document.getElementById('meshActiveName');
      const video = document.getElementById('meshVideo');
      const note = document.getElementById('meshVideoNote');

      const meshes = {
        cleaner: { label: 'Cleaner', file: 'mesh_cleaner.glb', video: 'cleaner.mp4' },
        coke: { label: 'Coke', file: 'mesh_coke.glb', video: null },
        electricdrill: { label: 'Electric Drill', file: 'mesh_electricdrill.glb', video: 'electricdrill.mp4' },
        pot: { label: 'Pot', file: 'mesh_pot.glb', video: 'pot.mp4' },
        scissor: { label: 'Scissor', file: 'mesh_scissor.glb', video: 'scissor.mp4' },
        spoon: { label: 'Spoon', file: 'mesh_spoon.glb', video: 'spoon.mp4' }
      };

      const setMesh = (key) => {
        const entry = meshes[key];
        if (!entry || !raw) return;
        const src = `./assets/trellis/${entry.file}`;
        raw.setAttribute('src', src);
        raw.setAttribute('camera-orbit', 'auto auto 600%');
        raw.setAttribute('min-camera-orbit', 'auto auto 200%');
        raw.setAttribute('max-camera-orbit', 'auto auto 1000%');
        raw.setAttribute('field-of-view', '85deg');
        if (activeName) activeName.textContent = entry.label;
        if (video) {
          if (entry.video) {
            video.src = `./assets/videos/objects/${entry.video}`;
            video.classList.remove('hidden');
            video.load();
            video.play().catch(() => {});
            if (note) note.textContent = '';
          } else {
            video.pause();
            video.removeAttribute('src');
            video.classList.add('hidden');
            if (note) note.textContent = 'No scan video available for this object.';
          }
        }
      };

      select?.addEventListener('change', (e) => setMesh(e.target.value));
      setMesh(select?.value || 'cleaner');
    });

    // Simple interactive scatter backed by exported data (PolaRiS vs LIBERO)
    document.addEventListener('DOMContentLoaded', () => {
      const svg = document.getElementById('corr-scatter');
      const statusEl = document.getElementById('scatter-status');
      const policyLegend = document.getElementById('policy-legend');
      const envLegend = document.getElementById('env-legend');
      if (!svg) return;

      const margin = { top: 20, right: 20, bottom: 40, left: 50 };
      const width = 520 - margin.left - margin.right;
      const height = 320 - margin.top - margin.bottom;
      const min = 0;
      const max = 1;

      const createEl = (tag, attrs) => {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v));
        return el;
      };

      const renderScatter = (data) => {
      // Clear
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      const g = createEl('g', { transform: `translate(${margin.left},${margin.top})` });
      svg.appendChild(g);

      const scaleX = (v) => (v - min) / (max - min) * width;
      const scaleY = (v) => height - (v - min) / (max - min) * height;

        // Grid lines
        const gridCount = 5;
        for (let i = 1; i < gridCount; i++) {
          const gx = (i / gridCount) * width;
          const gy = (i / gridCount) * height;
          g.appendChild(createEl('line', { x1: gx, y1: 0, x2: gx, y2: height, stroke: '#e0e0e0', 'stroke-width': 1, 'stroke-dasharray': '4 4' }));
          g.appendChild(createEl('line', { x1: 0, y1: gy, x2: width, y2: gy, stroke: '#e0e0e0', 'stroke-width': 1, 'stroke-dasharray': '4 4' }));
        }

      // Axes lines
        g.appendChild(createEl('line', { x1: 0, y1: height, x2: width, y2: height, stroke: '#333', 'stroke-width': 2 }));
        g.appendChild(createEl('line', { x1: 0, y1: 0, x2: 0, y2: height, stroke: '#333', 'stroke-width': 2 }));

      // Axis labels
        const xLabel = createEl('text', { x: width / 2, y: height + 32, 'text-anchor': 'middle', fill: '#333', 'font-size': '12', 'font-weight': '600' });
      xLabel.textContent = 'Simulation Success Rate';
      g.appendChild(xLabel);
        const yLabel = createEl('text', { x: -36, y: height / 2, 'text-anchor': 'middle', fill: '#333', 'font-size': '12', 'font-weight': '600', transform: `rotate(-90 -36 ${height / 2})` });
      yLabel.textContent = 'Real-World Success Rate';
      g.appendChild(yLabel);

      // Diagonal reference
        g.appendChild(createEl('line', { x1: 0, y1: height, x2: width, y2: 0, stroke: '#999', 'stroke-dasharray': '6 4', 'stroke-width': 2, 'stroke-opacity': 0.6 }));

      // Tooltip
      const tooltip = document.createElement('div');
      tooltip.className = 'scatter-tooltip';
      document.body.appendChild(tooltip);

        const polarisEnvPalette = ['#41245f', '#8326df', '#b392e0'];
        const liberoEnvPalette = ['#966f1a', '#c28426', '#E0AF67'];
        const policyMarkerPool = ['circle', 'square', 'triangle', 'diamond', 'circle'];
        const policyShapeMap = {};

        // Stable shapes per policy (matches superplot idea: fixed shape per policy)
        const uniquePolicies = Array.from(new Set(data.map((d) => d.policy || d.name)));
        uniquePolicies.forEach((pol, idx) => {
          policyShapeMap[pol] = policyMarkerPool[idx % policyMarkerPool.length];
        });

        const envColor = (env, source) => {
          if (!env) return source === 'polaris' ? '#1f3c8f' : 'rgba(160,165,175,0.9)';
          const palette = source === 'polaris' ? polarisEnvPalette : liberoEnvPalette;
          const idx = Math.abs(env.split('').reduce((a, c) => a + c.charCodeAt(0), 0)) % palette.length;
          return palette[idx];
        };
        const strokeColor = (source) => (source === 'polaris' ? '#12306c' : 'rgba(130,135,145,0.9)');
        const markerForPolicy = (policy) => policyShapeMap[policy] || 'circle';

      data.forEach((d) => {
        const cx = scaleX(d.sim);
        const cy = scaleY(d.real);
          const fill = envColor(d.environment || '', d.source);
          const stroke = strokeColor(d.source);
          const marker = markerForPolicy(d.policy || d.name);
          let node;
          const baseFillOpacity = d.source === 'polaris' ? 0.9 : 0.6;
          const baseStrokeWidth = 1.5;
          const baseSquare = 10;
          const baseCircle = 6;
          const baseTri = 12;
          const baseDiamond = 10;
          if (marker === 'square') {
            const s = baseSquare;
            node = createEl('rect', {
              x: cx - s / 2,
              y: cy - s / 2,
              width: s,
              height: s,
              rx: 2,
              fill,
              'fill-opacity': baseFillOpacity,
              stroke,
              'stroke-width': baseStrokeWidth
            });
          } else if (marker === 'triangle') {
            const h = baseTri;
            const points = [
              `${cx},${cy - h}`,
              `${cx - h},${cy + h * 0.8}`,
              `${cx + h},${cy + h * 0.8}`
            ].join(' ');
            node = createEl('polygon', {
              points,
              fill,
              'fill-opacity': baseFillOpacity,
              stroke,
              'stroke-width': baseStrokeWidth
            });
          } else if (marker === 'diamond') {
            const h = baseDiamond;
            const points = [
              `${cx},${cy - h}`,
              `${cx - h},${cy}`,
              `${cx},${cy + h}`,
              `${cx + h},${cy}`
            ].join(' ');
            node = createEl('polygon', {
              points,
              fill,
              'fill-opacity': baseFillOpacity,
              stroke,
              'stroke-width': baseStrokeWidth
            });
          } else {
            // circle / default
            node = createEl('circle', {
              cx,
              cy,
              r: baseCircle,
              fill,
              'fill-opacity': baseFillOpacity,
              stroke,
              'stroke-width': baseStrokeWidth
            });
          }
        node.addEventListener('mouseenter', (e) => {
          tooltip.style.opacity = '1';
            tooltip.textContent = `${d.policy || d.name}: Sim ${Math.round(d.sim * 100)}%, Real ${Math.round(d.real * 100)}%${d.environment ? ` | Env: ${d.environment}` : ''}`;
          tooltip.style.left = `${e.pageX + 10}px`;
          tooltip.style.top = `${e.pageY + 10}px`;
        });
        node.addEventListener('mouseleave', () => {
          tooltip.style.opacity = '0';
        });
        node.addEventListener('mousemove', (e) => {
          tooltip.style.left = `${e.pageX + 10}px`;
          tooltip.style.top = `${e.pageY + 10}px`;
        });
        g.appendChild(node);
      });

        // Legends
        if (policyLegend) {
          policyLegend.innerHTML = '';
          const legendColor = '#41245f';
          uniquePolicies.forEach((pol) => {
            const shape = markerForPolicy(pol);
            const item = document.createElement('span');
            item.className = 'legend-item';
            const shapeEl = document.createElement('span');
            shapeEl.className = `legend-shape ${shape}`;
            shapeEl.style.background = shape === 'triangle' ? 'transparent' : legendColor;
            if (shape === 'triangle') shapeEl.style.borderBottomColor = legendColor;
            shapeEl.style.borderColor = legendColor;
            item.appendChild(shapeEl);
            item.append(pol);
            policyLegend.appendChild(item);
          });
        }
        if (envLegend) {
          envLegend.innerHTML = '';
          const polEnv = Array.from(new Set(data.filter((d) => d.source === 'polaris').map((d) => d.environment || ''))).filter(Boolean);
          const libEnv = Array.from(new Set(data.filter((d) => d.source === 'libero').map((d) => d.environment || ''))).filter(Boolean);
          polEnv.forEach((env) => {
            const item = document.createElement('span');
            item.className = 'legend-item';
            const shapeEl = document.createElement('span');
            shapeEl.className = 'legend-shape square';
            shapeEl.style.background = envColor(env, 'polaris');
            shapeEl.style.borderColor = '#12306c';
            item.appendChild(shapeEl);
            item.append(env);
            envLegend.appendChild(item);
          });
          libEnv.forEach((env) => {
            const item = document.createElement('span');
            item.className = 'legend-item';
            const shapeEl = document.createElement('span');
            shapeEl.className = 'legend-shape circle';
            shapeEl.style.background = envColor(env, 'libero');
            shapeEl.style.borderColor = 'rgba(130,135,145,0.9)';
            item.appendChild(shapeEl);
            item.append(env);
            envLegend.appendChild(item);
          });
        }
      };

      fetch('./assets/data/correlation.json')
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res.json();
        })
        .then((records) => {
          if (!Array.isArray(records) || records.length === 0) {
            if (statusEl) statusEl.textContent = 'No correlation data available.';
            return;
          }
          // Normalize fields
          const data = records.map((r, idx) => ({
            name: r.name || r.policy || `pt-${idx + 1}`,
            policy: r.policy || '',
            environment: r.environment || '',
            sim: Number(r.sim),
            real: Number(r.real),
            source: r.source || 'polaris'
          }));
          renderScatter(data);
          if (statusEl) statusEl.textContent = '';
        })
        .catch((err) => {
          console.warn('Correlation data load failed; showing demo data', err);
          if (statusEl) statusEl.textContent = 'Showing demo points (data file missing).';
          const demo = [];
          for (let i = 0; i < 10; i++) {
            const sim = 0.6 + Math.random() * 0.3;
            const real = Math.min(1, Math.max(0, sim + (Math.random() * 0.1 - 0.05)));
            demo.push({ name: `POLARIS ${i + 1}`, sim, real, source: 'polaris' });
          }
          for (let i = 0; i < 10; i++) {
            demo.push({ name: `LIBERO ${i + 1}`, sim: Math.random(), real: Math.random(), source: 'libero' });
          }
          renderScatter(demo);
        });
    });

    // Interactive bar plot (sim vs real per environment)
    document.addEventListener('DOMContentLoaded', () => {
      const svg = document.getElementById('bar-plot');
      const statusEl = document.getElementById('bar-status');
      if (!svg) return;

      const colors = {
        sim: '#8e7dbe',
        real: '#e98a73',
        axis: '#333',
        grid: '#e0e0e0'
      };

      const margin = { top: 20, right: 20, bottom: 60, left: 60 };
      const width = 640 - margin.left - margin.right;
      const height = 360 - margin.top - margin.bottom;

      const createEl = (tag, attrs) => {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v));
        return el;
      };

      const renderBars = (records) => {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        // Define shadow filter once
        const defs = createEl('defs', {});
        const filter = createEl('filter', { id: 'barShadow', x: '-40%', y: '-40%', width: '180%', height: '180%' });
        filter.innerHTML = `
          <feDropShadow dx="2" dy="2" stdDeviation="3" flood-color="rgba(0,0,0,0.18)"/>
          <feDropShadow dx="-2" dy="2" stdDeviation="3" flood-color="rgba(0,0,0,0.14)"/>
        `;
        defs.appendChild(filter);
        svg.appendChild(defs);

        const g = createEl('g', { transform: `translate(${margin.left},${margin.top})` });
        svg.appendChild(g);

        const envs = records.map((r) => r.environment || '');
        const maxVal = Math.max(...records.map((r) => Math.max(r.sim, r.real)), 1);

        const xBand = (idx) => (idx * (width / envs.length)) + 0.1 * (width / envs.length);
        const bandWidth = 0.8 * (width / envs.length);
        const scaleY = (v) => height - (v / maxVal) * height;

        // Grid lines
        const gridCount = 5;
        for (let i = 0; i <= gridCount; i++) {
          const y = (i / gridCount) * height;
          g.appendChild(createEl('line', { x1: 0, y1: y, x2: width, y2: y, stroke: colors.grid, 'stroke-width': 1, 'stroke-dasharray': '4 4' }));
        }

        // Axes
        g.appendChild(createEl('line', { x1: 0, y1: height, x2: width, y2: height, stroke: colors.axis, 'stroke-width': 2 }));
        g.appendChild(createEl('line', { x1: 0, y1: 0, x2: 0, y2: height, stroke: colors.axis, 'stroke-width': 2 }));

        // Tooltip
        const tooltip = document.createElement('div');
        tooltip.className = 'scatter-tooltip';
        document.body.appendChild(tooltip);

        records.forEach((r, idx) => {
          const baseX = xBand(idx);
          const simH = height - scaleY(r.sim);
          const realH = height - scaleY(r.real);
          const barW = bandWidth / 2.4;

          const simRect = createEl('rect', {
            x: baseX,
            y: scaleY(r.sim),
            width: barW,
            height: simH,
            fill: colors.sim,
            stroke: '#6f5faa',
            'stroke-width': 1.5,
            rx: 2,
            'filter': 'url(#barShadow)'
          });
          const realRect = createEl('rect', {
            x: baseX + barW + 6,
            y: scaleY(r.real),
            width: barW,
            height: realH,
            fill: colors.real,
            stroke: '#c7705d',
            'stroke-width': 1.5,
            rx: 2,
            'filter': 'url(#barShadow)'
          });

          [simRect, realRect].forEach((node, i) => {
            node.addEventListener('mouseenter', (e) => {
              tooltip.style.opacity = '1';
              const label = i === 0 ? 'Sim' : 'Real';
              const val = i === 0 ? r.sim : r.real;
              tooltip.textContent = `${r.environment}: ${label} ${Math.round(val * 100)}%`;
              tooltip.style.left = `${e.pageX + 10}px`;
              tooltip.style.top = `${e.pageY + 10}px`;
            });
            node.addEventListener('mouseleave', () => {
              tooltip.style.opacity = '0';
            });
            node.addEventListener('mousemove', (e) => {
              tooltip.style.left = `${e.pageX + 10}px`;
              tooltip.style.top = `${e.pageY + 10}px`;
            });
          });

          g.appendChild(simRect);
          g.appendChild(realRect);

          // x labels
          const lbl = createEl('text', {
            x: baseX + barW + 3,
            y: height + 24,
            'text-anchor': 'middle',
            fill: '#333',
            'font-size': '11'
          });
          lbl.textContent = r.environment || `Env ${idx + 1}`;
          g.appendChild(lbl);
        });

        // y-axis ticks/labels
        for (let i = 0; i <= gridCount; i++) {
          const val = (i / gridCount) * maxVal;
          const y = height - (val / maxVal) * height;
          const t = createEl('text', { x: -10, y: y + 4, 'text-anchor': 'end', fill: '#333', 'font-size': '11' });
          t.textContent = `${Math.round(val * 100)}%`;
          g.appendChild(t);
        }

        if (statusEl) statusEl.textContent = '';
      };

      fetch('./assets/data/bar.json')
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res.json();
        })
        .then((records) => {
          if (!Array.isArray(records) || records.length === 0) {
            if (statusEl) statusEl.textContent = 'No bar data available.';
            return;
          }
          const data = records.map((r) => ({
            environment: r.environment || '',
            sim: Number(r.sim),
            real: Number(r.real)
          }));
          renderBars(data);
        })
        .catch((err) => {
          console.warn('Bar data load failed; showing demo bars', err);
          if (statusEl) statusEl.textContent = '';
          const envs = ['Env A', 'Env B', 'Env C'];
          const demo = envs.map((env) => ({
            environment: env,
            sim: 0.6 + Math.random() * 0.3,
            real: 0.5 + Math.random() * 0.35
          }));
          renderBars(demo);
        });
    });

    // Policy evaluation comparison (sim vs real per env)
    document.addEventListener('DOMContentLoaded', () => {
      const container = document.getElementById('policy-list');
      const statusEl = document.getElementById('policy-status');
      if (!container) return;

      const renderPolicies = (records) => {
        container.innerHTML = '';
        const byPolicy = {};
        records.forEach((r) => {
          const pol = r.policy || 'Unknown';
          if (!byPolicy[pol]) byPolicy[pol] = [];
          byPolicy[pol].push(r);
        });

        Object.entries(byPolicy).forEach(([pol, rows]) => {
          const item = document.createElement('div');
          item.className = 'policy-item';

          const title = document.createElement('div');
          title.className = 'policy-title';
          title.textContent = pol;
          item.appendChild(title);

          const table = document.createElement('table');
          table.className = 'policy-table';
          const thead = document.createElement('thead');
          thead.innerHTML = '<tr><th>Env</th><th>Sim</th><th>Real</th></tr>';
          table.appendChild(thead);
          const tbody = document.createElement('tbody');
          rows.forEach((r) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${r.environment || ''}</td>
              <td class="value-sim">${Math.round(r.sim * 100)}%</td>
              <td class="value-real">${Math.round(r.real * 100)}%</td>
            `;
            tbody.appendChild(tr);
          });
          table.appendChild(tbody);
          item.appendChild(table);
          container.appendChild(item);
        });
        if (statusEl) statusEl.textContent = '';
      };

      fetch('./assets/data/policy_eval.json')
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res.json();
        })
        .then((records) => {
          if (!Array.isArray(records) || records.length === 0) {
            if (statusEl) statusEl.textContent = 'No policy data available.';
            return;
          }
          const data = records.map((r) => ({
            policy: r.policy || '',
            environment: r.environment || '',
            sim: Number(r.sim),
            real: Number(r.real)
          }));
          renderPolicies(data);
        })
        .catch((err) => {
          console.warn('Policy data load failed; showing demo data', err);
          if (statusEl) statusEl.textContent = '';
          const policies = [
            'paligemma_binning_droid_jointpos',
            'pi05_droid_jointpos',
            'pi0_droid_jointpos',
            'pi0_droid_jointpos_100k',
            'pi0_fast_droid_jointpos'
          ];
          const envs = ['Kitchen', 'Counter', 'Stovetop'];
          const demo = [];
          policies.forEach((p) => {
            envs.forEach((env) => {
              demo.push({
                policy: p,
                environment: env,
                sim: 0.6 + Math.random() * 0.3,
                real: 0.5 + Math.random() * 0.35
              });
            });
          });
          renderPolicies(demo);
        });
    });

    // Policy evaluation videos
    document.addEventListener('DOMContentLoaded', () => {
      const grid = document.getElementById('policy-video-grid');
      const statusEl = document.getElementById('policy-video-status');
      if (!grid) return;

      const renderVideos = (records) => {
        let idx = 0;

        const show = (dir) => {
          if (!records.length) return;
          const r = records[idx];
          grid.innerHTML = '';
          const card = document.createElement('div');
          card.className = 'policy-video-item';
          if (dir === 'next') card.classList.add('slide-in-right');
          if (dir === 'prev') card.classList.add('slide-in-left');
          card.addEventListener('animationend', () => {
            card.classList.remove('slide-in-right', 'slide-in-left');
          }, { once: true });
          const pair = document.createElement('div');
          pair.className = 'policy-video-pair';

          const addVid = (src, label) => {
            const wrap = document.createElement('div');
            wrap.className = 'policy-video-wrap';
            const v = document.createElement('video');
            v.src = src;
            v.autoplay = true;
            v.loop = true;
            v.muted = true;
            v.playsInline = true;
            wrap.appendChild(v);
            const lbl = document.createElement('div');
            lbl.className = 'policy-video-label';
            lbl.textContent = label;
            wrap.appendChild(lbl);
            return wrap;
          };

          if (r.simVideo) pair.appendChild(addVid(r.simVideo, 'Sim (pi05_contrain-1k)'));
          if (r.realVideo) pair.appendChild(addVid(r.realVideo, 'Real (pi05_joint_pos)'));

          card.appendChild(pair);
          const meta = document.createElement('div');
          meta.className = 'policy-video-meta';
          const realPol = r.realPolicy ? ` / Real: ${r.realPolicy}` : '';
          meta.textContent = `${r.policy || ''}${realPol} — ${r.environment || ''}`;
          card.appendChild(meta);
          grid.appendChild(card);
        };

        const controls = document.createElement('div');
        controls.className = 'policy-video-controls';
        const btnPrev = document.createElement('button');
        btnPrev.className = 'gallery-nav left';
        btnPrev.textContent = '‹';
        const btnNext = document.createElement('button');
        btnNext.className = 'gallery-nav right';
        btnNext.textContent = '›';
        controls.appendChild(btnPrev);
        controls.appendChild(btnNext);
        grid.parentElement.insertBefore(controls, grid.nextSibling);

        btnPrev.addEventListener('click', () => {
          idx = (idx - 1 + records.length) % records.length;
          show('prev');
        });
        btnNext.addEventListener('click', () => {
          idx = (idx + 1) % records.length;
          show('next');
        });

        show();
        if (statusEl) statusEl.textContent = '';
      };

      fetch('./assets/data/policy_videos.json')
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res.json();
        })
        .then((records) => {
          if (!Array.isArray(records) || records.length === 0) {
            if (statusEl) statusEl.textContent = 'No video data available.';
            return;
          }
          renderVideos(records);
        })
        .catch((err) => {
          console.warn('Policy video data load failed; showing demo videos', err);
          if (statusEl) statusEl.textContent = '';
          const demo = [
            { policy: 'pi05_constrain-1k', realPolicy: 'pi05_joint_pos', environment: 'FruitBus', simVideo: './assets/videos/sim_rollouts/fruitbus.mp4', realVideo: './assets/videos/real_rollouts/fruitbus.mp4' },
            { policy: 'pi05_constrain-1k', realPolicy: 'pi05_joint_pos', environment: 'Stack', simVideo: './assets/videos/sim_rollouts/stack.mp4', realVideo: './assets/videos/real_rollouts/stack.mp4' },
            { policy: 'pi05_constrain-1k', realPolicy: 'pi05_joint_pos', environment: 'PanClean', simVideo: './assets/videos/sim_rollouts/panclean.mp4', realVideo: './assets/videos/real_rollouts/panclean.mp4' }
          ];
          renderVideos(demo);
        });
    });
  </script>
</body>
</html>

